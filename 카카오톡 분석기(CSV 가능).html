<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>MBTI Nìœ í˜• íë§ë°© ëŒ€í™” ë¹ˆë„ ë¶„ì„ ğŸŒ±ğŸ’¬</title>
  <style>
    body { font-family: 'Noto Sans KR', Arial, sans-serif; margin: 30px; }
    #dashboard {margin:15px 0 16px 0;}
    #dashSummary { font-size: 1.1em; color:#1b2933; margin-bottom:4px; display:flex; align-items:center; gap:18px;}
    .dash-sep {color:#bbb; font-weight:normal;}
    .dash-hr {border:0; border-top:1.3px solid #ccc; margin:8px 0 8px 0;}
    .highlight {color:#2063b0; font-weight:bold;}
    .label-light {color:#666;}
    .rankingline {font-size:1.04em; margin-bottom:2px;}
    #topArea { display:flex; align-items: center; gap:14px; margin-bottom: 2px;}
    #dateControls { margin-top: 20px; }
    #filterBox { margin: 24px 0 8px 0; }
    #optionsBox { margin: 14px 0 0 0; }
    #nickFilter { width: 50%; min-width: 240px; min-height: 80px; max-width:400px; }
    .desc { color: #888; font-size: 13px; }
    .row-in { background: #e7f1ff !important; color: #1858c9 !important; font-weight:bold; }
    .row-zero { background: #f2f2f2 !important; color: #aaa !important; }
    .legendbox {margin: 15px 0 7px 0; display:none; align-items: center;}
    .legendchip {display:inline-block;width:16px;height:16px;margin-right:6px;vertical-align:middle;border-radius:4px;}
    .inchip {background:#e7f1ff;border:1px solid #1858c9;}
    .zerochip {background:#f2f2f2;border:1px solid #aaa;}
    .legendtext {font-size: 14px; color:#444;}
    h2 { font-size: 1.8em; }
    th, td { text-align:center; }
    input[type="checkbox"] { transform:scale(1.2); margin-right: 6px;}
    label { margin-right:18px;}
    #captureBtn { 
      background: #607D8B; color: #fff; border:none; border-radius:7px;
      padding: 6px 15px; font-size: 15px; cursor:pointer; font-weight:500;
      transition: background 0.2s;
      vertical-align:middle;
      letter-spacing:0.5px;
      margin-bottom:1px;
    }
    #captureBtn:hover { background:#455A64; }
    #trendSummary, #summaryTop, #divider, #resultCount {display:none;}
    #checkboxBar { margin-bottom: 8px;}
    .lightgray { color:#666; }
  </style>
</head>
<body>
  <div id="captureArea">
    <h2>ğŸŒ±ğŸ’¬ MBTI Nìœ í˜• íë§ë°© ëŒ€í™” ë¹ˆë„ ë¶„ì„ ğŸ’šğŸ§ </h2>
    <div id="topArea">
      <!-- âœ… CSV ì§€ì›: acceptì— .csv ì¶”ê°€ (ë ˆì´ì•„ì›ƒ ì˜í–¥ ì—†ìŒ) -->
      <input type="file" id="fileInput" accept=".txt,.csv">
      <button id="captureBtn" onclick="capturePage()">í˜ì´ì§€ ì´ë¯¸ì§€ë¡œ ì €ì¥ (PNG)</button>
    </div>
    <div id="dateControls" style="display:none;">
      <label for="startDate">ì‹œì‘ ë‚ ì§œ:</label>
      <input type="date" id="startDate">
      <label for="endDate">ì¢…ë£Œ ë‚ ì§œ:</label>
      <input type="date" id="endDate">
      <button onclick="updateChart()">ê¸°ê°„ ë¶„ì„</button>
    </div>
    <div id="filterBox" style="display:none;">
      <b>ë‹‰ë„¤ì„ í•„í„° <span style="font-weight:normal;color:#888;">(ìµœëŒ€ ê²€ìƒ‰ ì¸ì› 100ëª…)</span>:</b>
      <button style="margin-left:7px; font-size:13px; padding:4px 9px;" onclick="updateChart()">í•„í„° ì ìš©</button>
      <div style="height:5px"></div>
      <textarea id="nickFilter" placeholder="ì—¬ê¸°ì— ë‹‰ë„¤ì„ì„ ì¤„ë°”ê¿ˆìœ¼ë¡œ ì…ë ¥í•˜ì„¸ìš”"></textarea>
      <div class="desc">í•„í„° ë‹‰ë„¤ì„ì´ <b>íŒŒë€ìƒ‰</b>ì´ë©´ í•´ë‹¹ ê¸°ê°„ì— ëŒ€í™” ì°¸ì—¬, <b>íšŒìƒ‰</b>ì´ë©´ ë¯¸ì°¸ì—¬ì…ë‹ˆë‹¤.<br>
      ì•„ë¬´ê²ƒë„ ì…ë ¥í•˜ì§€ ì•Šìœ¼ë©´ ì „ì²´ ë‹‰ë„¤ì„ì´ í‘œì‹œë©ë‹ˆë‹¤.<br>
      â€» ìŠ¤í˜ì´ìŠ¤(ê³µë°±)ë„ ë‹‰ë„¤ì„ ì¼ë¶€ë¡œ ì²˜ë¦¬í•©ë‹ˆë‹¤.</div>
    </div>
    <!-- âœ… ëŒ€ì‹œë³´ë“œ ìš”ì•½ ì¶”ê°€ -->
    <div id="dashboard" style="margin-bottom:10px; display:none;">
      <div id="dashSummary"></div>
      <div class="dash-hr"></div>
      <div class="rankingline" id="monthlyTop"></div>
      <div class="rankingline" id="hot7days"></div>
      <div class="dash-hr"></div>
    </div>
    <div id="optionsBox" style="display:none;">
      <div id="checkboxBar">
        <label><input type="checkbox" id="showFirst" checked onchange="updateChart()">ì²« ëŒ€í™” í¬í•¨</label>
        <label><input type="checkbox" id="showLast" checked onchange="updateChart()">ë§ˆì§€ë§‰ ëŒ€í™” í¬í•¨</label>
        <label><input type="checkbox" id="showDay" checked onchange="updateChart()">ì¶œëª° ìš”ì¼</label>
        <label><input type="checkbox" id="showHour" checked onchange="updateChart()">ì¶œëª° ì‹œê°„</label>
        <!-- ì£¼ìš”í‚¤ì›Œë“œ ì²´í¬ë°•ìŠ¤ ì‚­ì œ -->
      </div>
      <label><input type="checkbox" id="showIn" checked onchange="updateChart()">ì°¸ì—¬</label>
      <label><input type="checkbox" id="showOut" checked onchange="updateChart()">ë¯¸ì°¸ì—¬</label>
    </div>
    <div class="legendbox" id="legendBox">
      <span class="legendchip inchip"></span><span class="legendtext">ì°¸ì—¬</span> &nbsp; 
      <span class="legendchip zerochip"></span><span class="legendtext">ë¯¸ì°¸ì—¬</span>
    </div>
    <div id="result"></div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script>
    let messages = [];
    let uniqueDates = [];

    // (ë¶ˆìš©ì–´ ë¦¬ìŠ¤íŠ¸/í•¨ìˆ˜ ë“± ê¸°ì¡´ ë™ì¼í•˜ê²Œ ìœ ì§€)
    // ...banWords, isBanWord í•¨ìˆ˜ ë“± ì—¬ê¸°ì— ë¶™ì—¬ë„£ìœ¼ì„¸ìš”...

    function pad(n) { return n<10 ? '0'+n : n; }
    function isDateLike(text) { return /^\d{4}ë…„\s*\d{1,2}ì›”\s*\d{1,2}ì¼/.test(String(text||"").trim()); }
    function isTimeLike(text) { return /^(ì˜¤ì „|ì˜¤í›„)\s*\d{1,2}:\d{2}$/.test(String(text||"").trim()); }

    /* =========================
       âœ… ê¸°ì¡´ TXT íŒŒì„œ (ë³€ê²½ ì—†ìŒ)
       ========================= */
    function parseKakaoTxt(text) {
      messages = [];
      let lines = text.split('\n');
      let currentDateStr = null;
      let datePattern = /^-+\s*(\d{4})ë…„\s*(\d{1,2})ì›”\s*(\d{1,2})ì¼/;
      let msgPattern = /^\[([^\[\]]+)\]\s+\[(ì˜¤ì „|ì˜¤í›„)\s*\d{1,2}:\d{2}\]\s*(.+)$/;
      let nicknamePattern = /^\[([^\[\]]+)\]\s+\[(ì˜¤ì „|ì˜¤í›„)\s*\d{1,2}:\d{2}\]/;
      for(let line of lines) {
        let dateMatch = line.match(datePattern);
        if(dateMatch) {
          currentDateStr = dateMatch[1] + '-' + pad(parseInt(dateMatch[2])) + '-' + pad(parseInt(dateMatch[3]));
          continue;
        }
        if(currentDateStr) {
          let msgMatch = line.match(msgPattern);
          if(msgMatch) {
            let user = msgMatch[1].trim();
            let time = msgMatch[2] + " " + line.match(/\[(ì˜¤ì „|ì˜¤í›„)\s*\d{1,2}:\d{2}\]/)[0].replace(/[\[\]]/g, "");
            let msg = msgMatch[3].trim();
            if (
              user.length > 0 &&
              !isDateLike(user) &&
              !isTimeLike(user)
            ) {
              messages.push({
                user: user,
                date: currentDateStr,
                time: time,
                msg: msg
              });
            }
          } else {
            let match = line.match(nicknamePattern);
            if(match) {
              let user = match[1].trim();
              let time = match[2] + " " + line.match(/\[(ì˜¤ì „|ì˜¤í›„)\s*\d{1,2}:\d{2}\]/)[0].replace(/[\[\]]/g, "");
              messages.push({
                user: user,
                date: currentDateStr,
                time: time,
                msg: ""
              });
            }
          }
        }
      }
      uniqueDates = Array.from(new Set(messages.map(x=>x.date))).sort();
    }

    /* =========================
       âœ… CSV ì§€ì› ì¶”ê°€ (ì‹ ê·œ)
       - ê¸°ì¡´ ê¸°ëŠ¥/ë ˆì´ì•„ì›ƒ ì˜í–¥ ì—†ìŒ
       ========================= */

    function stripBom(s){
      if(!s) return s;
      return s.charCodeAt(0) === 0xFEFF ? s.slice(1) : s;
    }

    function detectDelimiterOutOfQuotes(text){
      // ì²« 10ì¤„ ì •ë„ë¥¼ ëŒ€ìƒìœ¼ë¡œ, ë”°ì˜´í‘œ ë°–ì—ì„œ êµ¬ë¶„ì ë¹ˆë„ ì¸¡ì •
      let sample = stripBom(text||"");
      let maxLines = 10;
      let lineCount = 0;
      let inQuotes = false;
      let counts = {",":0, "\t":0, ";":0, "|":0};
      for(let i=0;i<sample.length;i++){
        let ch = sample[i];
        if(ch === '"'){
          // "" ì´ìŠ¤ì¼€ì´í”„
          if(inQuotes && sample[i+1] === '"'){ i++; continue; }
          inQuotes = !inQuotes;
          continue;
        }
        if(!inQuotes){
          if(ch in counts) counts[ch]++;
          if(ch === '\n'){
            lineCount++;
            if(lineCount >= maxLines) break;
          }
        }
      }
      let best = ",";
      let bestVal = -1;
      Object.keys(counts).forEach(k=>{
        if(counts[k] > bestVal){ bestVal = counts[k]; best = k; }
      });
      return best;
    }

    function parseCSVToRows(text, delimiter){
      // ìƒíƒœë¨¸ì‹  CSV íŒŒì„œ: ë”°ì˜´í‘œ/ì½¤ë§ˆ/ê°œí–‰/ë©€í‹°ë¼ì¸ í•„ë“œ ì§€ì›
      let s = stripBom(text||"");
      let rows = [];
      let row = [];
      let cell = "";
      let inQuotes = false;

      for(let i=0;i<s.length;i++){
        let ch = s[i];

        if(ch === '"'){
          if(inQuotes && s[i+1] === '"'){
            cell += '"';
            i++;
          } else {
            inQuotes = !inQuotes;
          }
          continue;
        }

        if(!inQuotes && ch === delimiter){
          row.push(cell);
          cell = "";
          continue;
        }

        if(!inQuotes && (ch === '\n' || ch === '\r')){
          // CRLF ì²˜ë¦¬
          if(ch === '\r' && s[i+1] === '\n') i++;
          row.push(cell);
          cell = "";
          // ë¹ˆ ì¤„ì€ ìŠ¤í‚µí•˜ë˜, ì™„ì „ ë¹ˆ rowë§Œ ì œì™¸
          if(row.some(v => String(v).trim() !== "")){
            rows.push(row);
          }
          row = [];
          continue;
        }

        cell += ch;
      }

      // ë§ˆì§€ë§‰ ì…€/í–‰ ì²˜ë¦¬
      row.push(cell);
      if(row.some(v => String(v).trim() !== "")){
        rows.push(row);
      }
      return rows;
    }

    function normalizeHeaderKey(x){
      return String(x||"")
        .trim()
        .toLowerCase()
        .replace(/\s+/g,"")
        .replace(/[\u200b-\u200f]/g,""); // ì œë¡œí­ ë¬¸ì ì œê±°
    }

    function looksLikeHeader(row){
      // í—¤ë”ë¡œ ìì£¼ ì“°ì´ëŠ” í‚¤ê°€ í¬í•¨ë˜ë©´ í—¤ë”ë¡œ íŒë‹¨
      let keys = row.map(normalizeHeaderKey);
      let joined = keys.join("|");
      return (
        joined.includes("ë‚ ì§œ") || joined.includes("ì¼ì") || joined.includes("date") ||
        joined.includes("ì‹œê°„") || joined.includes("time") || joined.includes("ì‹œê°") ||
        joined.includes("ëŒ€í™”ëª…") || joined.includes("ë‹‰ë„¤ì„") || joined.includes("ë³´ë‚¸ì´") || joined.includes("user") || joined.includes("name") ||
        joined.includes("ë‚´ìš©") || joined.includes("message") || joined.includes("msg") || joined.includes("text") ||
        joined.includes("ì¼ì‹œ") || joined.includes("datetime") || joined.includes("timestamp")
      );
    }

    function parseDateAny(raw){
      let t = String(raw||"").trim();
      if(!t) return null;

      // 1) 2026ë…„ 1ì›” 4ì¼
      let m1 = t.match(/(\d{4})\s*ë…„\s*(\d{1,2})\s*ì›”\s*(\d{1,2})\s*ì¼/);
      if(m1) return `${m1[1]}-${pad(parseInt(m1[2]))}-${pad(parseInt(m1[3]))}`;

      // 2) 2026-01-04 / 2026.01.04 / 2026/01/04
      let m2 = t.match(/(\d{4})[.\-\/](\d{1,2})[.\-\/](\d{1,2})/);
      if(m2) return `${m2[1]}-${pad(parseInt(m2[2]))}-${pad(parseInt(m2[3]))}`;

      // 3) 01/04/2026 ë˜ëŠ” 1-4-2026 (ì›”/ì¼/ë…„ ê°€ëŠ¥ì„±)
      let m3 = t.match(/(\d{1,2})[.\-\/](\d{1,2})[.\-\/](\d{4})/);
      if(m3){
        // í•œêµ­ ë°ì´í„°ëŠ” ë³´í†µ yyyy-mm-ddê°€ ë§ì§€ë§Œ, ì˜ˆì™¸ë¡œ mm-dd-yyyyë„ ì§€ì›
        // ê¸°ë³¸ì€ ë§ˆì§€ë§‰ì´ 4ìë¦¬ë©´ ì—°ë„ë¡œ ë³´ê³  mm/dd/yyyyë¡œ ì²˜ë¦¬
        let mm = parseInt(m3[1]), dd = parseInt(m3[2]), yy = m3[3];
        if(mm>=1 && mm<=12 && dd>=1 && dd<=31) return `${yy}-${pad(mm)}-${pad(dd)}`;
      }

      return null;
    }

    function formatKoreanAmPmFrom24h(hh, mm){
      let h = parseInt(hh,10);
      let m = parseInt(mm,10);
      if(Number.isNaN(h) || Number.isNaN(m)) return null;
      let ampm = (h >= 12) ? "ì˜¤í›„" : "ì˜¤ì „";
      let h12 = h % 12;
      if(h12 === 0) h12 = 12;
      return `${ampm} ${h12}:${pad(m)}`;
    }

    function parseTimeAny(raw){
      let t = String(raw||"").trim();
      if(!t) return null;

      // 1) ì˜¤ì „ 1:23 / ì˜¤í›„ 12:05
      let m1 = t.match(/(ì˜¤ì „|ì˜¤í›„)\s*(\d{1,2}):(\d{2})/);
      if(m1){
        return `${m1[1]} ${parseInt(m1[2],10)}:${m1[3]}`;
      }

      // 2) 24ì‹œê°„ 13:05 or 13:05:22
      let m2 = t.match(/(\d{1,2}):(\d{2})(?::\d{2})?/);
      if(m2){
        let hh = parseInt(m2[1],10);
        let mm = parseInt(m2[2],10);
        if(hh>=0 && hh<=23 && mm>=0 && mm<=59){
          return formatKoreanAmPmFrom24h(hh, mm);
        }
      }

      return null;
    }

    function parseDateTimeAny(raw){
      let t = String(raw||"").trim();
      if(!t) return {date:null, time:null};

      // "2026-01-04 13:05" / "2026.01.04 13:05:22"
      let m = t.match(/(\d{4}[.\-\/]\d{1,2}[.\-\/]\d{1,2})\s+(.+)/);
      if(m){
        let d = parseDateAny(m[1]);
        let ti = parseTimeAny(m[2]);
        return {date:d, time:ti};
      }

      // "2026ë…„ 1ì›” 4ì¼ ì˜¤í›„ 1:05"
      let d2 = parseDateAny(t);
      let ti2 = parseTimeAny(t);
      return {date:d2, time:ti2};
    }

    function parseKakaoCsv(text){
      messages = [];

      let delimiter = detectDelimiterOutOfQuotes(text);
      let rows = parseCSVToRows(text, delimiter);
      if(!rows || rows.length === 0){
        uniqueDates = [];
        return;
      }

      let startRow = 0;
      let header = null;
      if(looksLikeHeader(rows[0])){
        header = rows[0].map(h => String(h||"").trim());
        startRow = 1;
      }

      let idx = {date:-1, time:-1, user:-1, msg:-1, datetime:-1};

      if(header){
        let keys = header.map(normalizeHeaderKey);

        function findIndex(candidates){
          for(let i=0;i<keys.length;i++){
            for(let c of candidates){
              if(keys[i] === c) return i;
            }
          }
          // ë¶€ë¶„ í¬í•¨ë„ í—ˆìš©
          for(let i=0;i<keys.length;i++){
            for(let c of candidates){
              if(keys[i].includes(c)) return i;
            }
          }
          return -1;
        }

        idx.date = findIndex(["date","ë‚ ì§œ","ì¼ì","day"]);
        idx.time = findIndex(["time","ì‹œê°„","ì‹œê°"]);
        idx.user = findIndex(["user","name","nickname","ëŒ€í™”ëª…","ë‹‰ë„¤ì„","ì‘ì„±ì","ë³´ë‚¸ì‚¬ëŒ","ë³´ë‚¸ì´","ì‚¬ìš©ì"]);
        idx.msg  = findIndex(["msg","message","ë‚´ìš©","í…ìŠ¤íŠ¸","text","body","ëŒ€í™”"]);

        idx.datetime = findIndex(["datetime","ì¼ì‹œ","ë‚ ì§œì‹œê°„","timestamp","date_time","dateandtime"]);
      }

      function guessIndexes(row){
        // í—¤ë”ê°€ ì—†ê±°ë‚˜, ì¼ë¶€ ì¹¼ëŸ¼ì´ ë¹„ì–´ìˆëŠ” ê²½ìš°ë¥¼ ìœ„í•œ ì¶”ì •
        // ê°€ì¥ í”í•œ: date, time, user, msg
        let n = row.length;

        // 1) date/time ë¶„ë¦¬í˜•
        if(n >= 3){
          let d0 = parseDateAny(row[0]);
          let t1 = parseTimeAny(row[1]);
          if(d0 && t1){
            return {date:0, time:1, user:2, msg:(n>=4?3:-1), datetime:-1};
          }
        }

        // 2) datetime ë‹¨ì¼í˜• (ì²« ì»¬ëŸ¼)
        let dt0 = parseDateTimeAny(row[0]);
        if(dt0.date && dt0.time && n >= 2){
          return {date:-1, time:-1, user:1, msg:(n>=3?2:-1), datetime:0};
        }

        // 3) ë§ˆì§€ë§‰ì´ ë©”ì‹œì§€ì¼ í™•ë¥ ì´ ë†’ë‹¤ê³  ë³´ê³  userëŠ” ê·¸ ì§ì „
        if(n >= 3){
          return {date:0, time:1, user:n-2, msg:n-1, datetime:-1};
        }

        // 4) ìµœì†Œ: userë§Œ ìˆëŠ” ê²½ìš°(ì¹´ìš´íŠ¸ë§Œì´ë¼ë„)
        if(n >= 1){
          return {date:-1, time:-1, user:0, msg:-1, datetime:-1};
        }

        return {date:-1, time:-1, user:-1, msg:-1, datetime:-1};
      }

      for(let r = startRow; r < rows.length; r++){
        let row = rows[r];

        // ì¸ë±ìŠ¤ê°€ ë¶€ì¡±í•˜ê±°ë‚˜ í—¤ë”ê°€ ì—†ìœ¼ë©´ ì¶”ì •
        let useIdx = idx;
        if(!header || (idx.user === -1 && idx.datetime === -1)){
          useIdx = guessIndexes(row);
        }

        let userRaw = (useIdx.user >= 0 && row[useIdx.user] != null) ? String(row[useIdx.user]) : "";
        let msgRaw  = (useIdx.msg  >= 0 && row[useIdx.msg]  != null) ? String(row[useIdx.msg])  : "";

        // date/time í™•ë³´
        let dateStr = null;
        let timeStr = null;

        if(useIdx.datetime >= 0 && row[useIdx.datetime] != null){
          let dt = parseDateTimeAny(row[useIdx.datetime]);
          dateStr = dt.date;
          timeStr = dt.time;
        }

        if(!dateStr && useIdx.date >= 0 && row[useIdx.date] != null){
          dateStr = parseDateAny(row[useIdx.date]);
        }
        if(!timeStr && useIdx.time >= 0 && row[useIdx.time] != null){
          timeStr = parseTimeAny(row[useIdx.time]);
        }

        // ë‹¤ë¥¸ ì¹¼ëŸ¼ì—ì„œë¼ë„ datetime ì¶”ì •
        if(!dateStr || !timeStr){
          // date/timeì´ í•œ ì¹¼ëŸ¼ì— ë¶™ì–´ìˆëŠ” ê²½ìš°ê°€ ìˆì–´, ì „ ì¹¼ëŸ¼ì„ í›‘ì–´ì„œ ë³´ì™„
          for(let c=0;c<row.length;c++){
            let dt = parseDateTimeAny(row[c]);
            if(!dateStr && dt.date) dateStr = dt.date;
            if(!timeStr && dt.time) timeStr = dt.time;
            if(dateStr && timeStr) break;
          }
        }

        // dateëŠ” í•„ìˆ˜ (ê¸°ê°„ ë¶„ì„/ë‹¬ë ¥ ì…ë ¥ì„ ìœ„í•´)
        if(!dateStr) continue;

        let user = String(userRaw||"").trim();
        if(
          user.length === 0 ||
          isDateLike(user) ||
          isTimeLike(user)
        ) continue;

        // timeì€ ì—†ì–´ë„ ì¹´ìš´íŠ¸ëŠ” ê°€ëŠ¥í•˜ê²Œ(ê¸°ì¡´ TXTë„ msg "" ë¼ì¸ í—ˆìš©í•˜ë“¯)
        if(!timeStr) timeStr = ""; // getHourëŠ” ë§¤ì¹­ ì‹¤íŒ¨ ì‹œ -1 ì²˜ë¦¬

        messages.push({
          user: user,
          date: dateStr,
          time: timeStr,
          msg: String(msgRaw||"").trim()
        });
      }

      uniqueDates = Array.from(new Set(messages.map(x=>x.date))).sort();
    }

    function parseByFile(text, filename){
      // í™•ì¥ì ìš°ì„  íŒë‹¨ + ì‹¤íŒ¨ ì‹œ ìë™ ëŒ€ì²´ íŒŒì‹±(ê¸°ì¡´ TXT ë³´í˜¸)
      let name = String(filename||"").toLowerCase();

      if(name.endsWith(".csv")){
        parseKakaoCsv(text);
        if(messages.length === 0){
          // í˜¹ì‹œ csvë¡œ ì˜ëª» ì €ì¥ëœ txtì¸ ê²½ìš° ëŒ€ë¹„
          parseKakaoTxt(text);
        }
      } else {
        parseKakaoTxt(text);
        if(messages.length === 0){
          // í˜¹ì‹œ txtë¡œ ì €ì¥ëœ csvì¸ ê²½ìš° ëŒ€ë¹„
          parseKakaoCsv(text);
        }
      }
    }

    function getNickFilterList() {
      let val = document.getElementById('nickFilter').value.trim();
      if(!val) return null;
      let arr = val.split(/\r?\n/).map(x=>x.trim()).filter(Boolean);
      return arr.slice(0,100); // ìµœëŒ€ 100ëª…
    }

    document.getElementById('fileInput').addEventListener('change', function(e) {
      let file = e.target.files[0];
      if (!file) return;
      let reader = new FileReader();
      reader.onload = function(evt) {
        // âœ… TXT/CSV ìë™ ë¶„ê¸° íŒŒì‹±
        parseByFile(evt.target.result, file.name);

        if(messages.length===0) {
          document.getElementById('result').innerHTML = "<b style='color:red'>ëŒ€í™” ë°ì´í„°ë¥¼ ê°ì§€í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì˜¬ë°”ë¥¸ ì¹´ì¹´ì˜¤í†¡ txt íŒŒì¼ì¸ì§€ í™•ì¸í•˜ì„¸ìš”.</b>";
          document.getElementById('dateControls').style.display = "none";
          document.getElementById('filterBox').style.display = "none";
          document.getElementById('optionsBox').style.display = "none";
          document.getElementById('legendBox').style.display = "none";
          document.getElementById('dashboard').style.display = "none";
          return;
        }
        let minDate = uniqueDates[0];
        let maxDate = uniqueDates[uniqueDates.length-1];
        document.getElementById('startDate').value = minDate;
        document.getElementById('endDate').value = maxDate;
        document.getElementById('startDate').min = minDate;
        document.getElementById('startDate').max = maxDate;
        document.getElementById('endDate').min = minDate;
        document.getElementById('endDate').max = maxDate;
        document.getElementById('dateControls').style.display = "";
        document.getElementById('filterBox').style.display = "";
        document.getElementById('optionsBox').style.display = "";
        document.getElementById('legendBox').style.display = "flex";
        document.getElementById('dashboard').style.display = "";
        updateChart();
      };
      reader.readAsText(file, "UTF-8");
    });

    function updateChart() {
      let start = document.getElementById('startDate').value;
      let end = document.getElementById('endDate').value;
      if (!start || !end) return;
      let st = new Date(start);
      let et = new Date(end);

      let showFirst = document.getElementById('showFirst').checked;
      let showLast = document.getElementById('showLast').checked;
      let showDay = document.getElementById('showDay').checked;
      let showHour = document.getElementById('showHour').checked;
      let showIn = document.getElementById('showIn') ? document.getElementById('showIn').checked : true;
      let showOut = document.getElementById('showOut') ? document.getElementById('showOut').checked : true;

      // ê¸°ê°„ë³„ë¡œ ë©”ì‹œì§€ ì¹´ìš´íŠ¸
      let filtered = messages.filter(x => {
        let d = new Date(x.date);
        return d >= st && d <= et;
      });

      // ê° userë³„ ëŒ€í™” ì‹œê° ìˆ˜ì§‘ + ë©”ì‹œì§€ ëª¨ìŒ
      let userMap = {}, firstMap = {}, lastMap = {},
          dayMap = {}, hourMap = {};
      for (let i = 0; i < filtered.length; ++i) {
        let m = filtered[i];
        if (!userMap[m.user]) {
          userMap[m.user] = 1;
          firstMap[m.user] = `${m.date} ${m.time}`;
          lastMap[m.user] = `${m.date} ${m.time}`;
        } else {
          userMap[m.user]++;
          lastMap[m.user] = `${m.date} ${m.time}`;
        }
        if (showDay) {
          let dt = new Date(m.date);
          let w = dt.getDay();
          if (!dayMap[m.user]) dayMap[m.user] = Array(7).fill(0);
          dayMap[m.user][w]++;
        }
        if (showHour) {
          let hour = getHour(m.time);
          if (!hourMap[m.user]) hourMap[m.user] = Array(24).fill(0);
          if (hour >= 0 && hour <= 23) hourMap[m.user][hour]++;
        }
      }
      // ì¶œëª° ìš”ì¼ ì´ë¦„
      const weekNames = ['ì¼','ì›”','í™”','ìˆ˜','ëª©','ê¸ˆ','í† '];

      let filterList = getNickFilterList();
      let userArr = [];
      if(filterList) {
        let tmpArr = filterList.map(u => [
          u,
          userMap[u] || 0,
          firstMap[u] || "-",
          lastMap[u] || "-",
          getMaxDay(dayMap[u], weekNames, showDay),
          getMaxHour(hourMap[u], showHour)
        ]);
        let arr_participated = tmpArr.filter(([u, c]) => c > 0).sort((a, b) => b[1] - a[1]);
        let arr_not = tmpArr.filter(([u, c]) => c === 0);
        userArr = arr_participated.concat(arr_not);
      } else {
        userArr = Object.keys(userMap).map(u => [
          u, userMap[u], firstMap[u], lastMap[u],
          getMaxDay(dayMap[u], weekNames, showDay),
          getMaxHour(hourMap[u], showHour)
        ]);
        userArr.sort((a, b) => b[1] - a[1]);
      }

      // íŠ¸ë Œë“œ ìš”ì•½ ê³„ì‚°
      let dailyCountMap = {};
      for (let m of filtered) {
        if (!dailyCountMap[m.date]) dailyCountMap[m.date] = 0;
        dailyCountMap[m.date]++;
      }
      let dayList = Object.keys(dailyCountMap).sort();
      let counts = dayList.map(d=>dailyCountMap[d]);
      let max = Math.max(...counts);
      let min = Math.min(...counts);
      let maxDay = dayList[counts.indexOf(max)];
      let minDay = dayList[counts.indexOf(min)];
      let avg = counts.length ? (counts.reduce((a,b)=>a+b,0)/counts.length).toFixed(1) : 0;

      // ì „ ì›” ìƒìœ„ í™œë™ì
      let prevMonth = (function(){
        let d = new Date(start);
        d.setMonth(d.getMonth()-1);
        return d.toISOString().slice(0,7);
      })();
      let prevMonthStats = {};
      messages.forEach(m=>{
        if(m.date && m.date.startsWith(prevMonth)) {
          if(!prevMonthStats[m.user]) prevMonthStats[m.user]=1;
          else prevMonthStats[m.user]++;
        }
      });
      let prevTop = "-";
      let prevMax = 0;
      Object.entries(prevMonthStats).forEach(([u,c])=>{
        if(c>prevMax){prevMax=c;prevTop=u;}
      });

      // ìµœê·¼ 7ì¼ ê¸‰ìƒìŠ¹ ì¸ë¬¼
      let endD = new Date(end);
      let weekStart = new Date(endD.getTime() - 6*24*60*60*1000);
      let weekStr = weekStart.toISOString().slice(0,10);
      let currWeekStats = {};
      let prevWeekStats = {};
      messages.forEach(m=>{
        let md = m.date;
        if(md >= weekStr && md <= end) {
          if(!currWeekStats[m.user]) currWeekStats[m.user]=1;
          else currWeekStats[m.user]++;
        }
        let d = new Date(md);
        let wPrev = new Date(endD.getTime() - 13*24*60*60*1000);
        let wPrevEnd = new Date(endD.getTime() - 7*24*60*60*1000);
        if(d >= wPrev && d < wPrevEnd){
          if(!prevWeekStats[m.user]) prevWeekStats[m.user]=1;
          else prevWeekStats[m.user]++;
        }
      });
      let riseTop = "-";
      let riseDiff = -9999;
      Object.keys(currWeekStats).forEach(u=>{
        let diff = currWeekStats[u] - (prevWeekStats[u]||0);
        if(diff>riseDiff && currWeekStats[u]>0){riseDiff=diff;riseTop=u;}
      });

      // ëŒ€ì‹œë³´ë“œ ì¶œë ¥ (userArr ê¸¸ì´ ì²´í¬ í›„)
      let inCount = userArr.filter(([_,c])=>c>0).length;
      let totalUserCount = userArr.length;
      document.getElementById('dashboard').style.display = "";
      document.getElementById('dashSummary').innerHTML = 
        `<span><b>ì°¸ì—¬ììˆ˜</b> <span class="lightgray">${inCount}/${totalUserCount}</span></span>` +
        `<span class="dash-sep">|</span><span><b>ìµœë‹¤ëŒ€í™”ì¼</b> <span class="label-light">${maxDay||"-"}</span> <span class="highlight">${max||0}íšŒ</span></span>` +
        `<span class="dash-sep">|</span><span><b>ìµœì†ŒëŒ€í™”ì¼</b> <span class="label-light">${minDay||"-"}</span> <span class="highlight">${min||0}íšŒ</span></span>` +
        `<span class="dash-sep">|</span><span><b>í‰ê· ëŒ€í™”ëŸ‰</b> <span class="highlight">${avg}íšŒ/ì¼</span></span>`;
      document.getElementById('monthlyTop').innerHTML =
        `<span>ì „ ì›” ê°€ì¥ ë§ì´ í™œë™í•œ ì¸ë¬¼: <span class="highlight">${prevTop}</span></span>`;
      document.getElementById('hot7days').innerHTML =
        `<span>ìµœê·¼ 7ì¼ê°„ ê¸‰ìƒìŠ¹ ì¤‘ì¸ ì¸ë¬¼: <span class="highlight">${riseTop}</span></span>`;

      // í‘œ ë Œë”ë§
      let filteredUserArr = userArr.filter(([_,c])=>{
        if(c>0 && showIn) return true;
        if(c===0 && showOut) return true;
        return false;
      });
      let ths = `<th>ëŒ€í™”ëª…</th><th>ëŒ€í™” íšŸìˆ˜</th>`;
      if(showFirst) ths += `<th>ì²« ëŒ€í™”</th>`;
      if(showLast) ths += `<th>ë§ˆì§€ë§‰ ëŒ€í™”</th>`;
      if(showDay) ths += `<th>ì¶œëª° ìš”ì¼</th>`;
      if(showHour) ths += `<th>ì¶œëª° ì‹œê°„</th>`;

      let resultHtml = `<table id="mainTable" border="1" cellpadding="5" style="border-collapse:collapse;margin-top:10px;">
      <tr>${ths}</tr>`;
      filteredUserArr.forEach(([u, cnt, f, l, day, hour]) => {
        let rowClass = cnt > 0 ? "row-in" : "row-zero";
        resultHtml += `<tr class="${rowClass}"><td>${u}</td><td>${cnt}</td>`;
        if(showFirst) resultHtml += `<td>${f}</td>`;
        if(showLast) resultHtml += `<td>${l}</td>`;
        if(showDay) resultHtml += `<td>${day}</td>`;
        if(showHour) resultHtml += `<td>${hour}</td>`;
        resultHtml += `</tr>`;
      });
      resultHtml += `</table>`;
      document.getElementById('result').innerHTML = resultHtml;
    }

    function getHour(timestr){
      let m = String(timestr||"").match(/(ì˜¤ì „|ì˜¤í›„)\s*(\d{1,2}):\d{2}/);
      if(!m) return -1;
      let h = parseInt(m[2]);
      if(m[1]==='ì˜¤í›„' && h<12) h+=12;
      if(m[1]==='ì˜¤ì „' && h===12) h=0;
      return h;
    }
    function getMaxDay(arr, weekNames, enabled){
      if(!enabled||!arr) return "-";
      let max = Math.max(...arr);
      if(max<=0) return "-";
      let idx = arr.indexOf(max);
      return weekNames[idx];
    }
    function getMaxHour(arr, enabled){
      if(!enabled||!arr) return "-";
      let max = Math.max(...arr);
      if(max<=0) return "-";
      let idx = arr.indexOf(max);
      return `${idx}ì‹œ~${idx+1}ì‹œ`;
    }
    function capturePage() {
      let area = document.getElementById('captureArea');
      html2canvas(area, {backgroundColor: '#fff', scale:2, windowWidth: document.body.scrollWidth}).then(function(canvas) {
        let link = document.createElement('a');
        link.download = 'mbti_ëŒ€í™”ë¹ˆë„ë¶„ì„.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
      });
    }
  </script>
</body>
</html>
